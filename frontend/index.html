<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>üá©üá™ German Tutor</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-hover: #5568d3;
            --danger: #f5365c;
            --success: #2dce89;
            --bg: #f8f9fa;
            --card: #ffffff;
            --text: #333333;
            --text-muted: #666666;
            --border: #e9ecef;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, #764ba2 100%);
            overflow: hidden;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .container {
            background: var(--card);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 500px;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--primary) 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .header p {
            font-size: 12px;
            opacity: 0.9;
        }

        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Session Controls */
        .session-controls {
            display: flex;
            gap: 8px;
            padding: 12px 15px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
        }

        .session-controls button {
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--primary);
            color: white;
        }

        .session-controls button:hover {
            background: var(--primary-hover);
        }

        .session-controls select {
            flex: 1;
            padding: 6px 10px;
            font-size: 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: white;
        }

        #deleteSessionBtn {
            background: var(--danger);
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            font-size: 11px;
        }

        .status-bar #status {
            color: var(--primary);
            font-weight: 600;
        }

        .status-bar #sessionInfo {
            color: var(--text-muted);
        }

        /* Chat Container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: #fafafa;
        }

        /* Message Bubbles */
        .message {
            display: flex;
            flex-direction: column;
            max-width: 85%;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            align-self: flex-end;
        }

        .message.agent {
            align-self: flex-start;
        }

        .message-bubble {
            padding: 10px 14px;
            border-radius: 16px;
            position: relative;
            word-wrap: break-word;
        }

        .message.user .message-bubble {
            background: var(--primary);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.agent .message-bubble {
            background: white;
            color: var(--text);
            border-bottom-left-radius: 4px;
            border: 1px solid var(--border);
        }

        .message-text {
            font-size: 15px;
            line-height: 1.5;
            margin-bottom: 4px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .correction {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .corrected {
            color: #2dce89;
            font-weight: 700;
        }

        .message.user .corrected {
            color: #a3f7d0;
        }

        .message.agent .corrected {
            color: var(--success);
        }

        .message-translation {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 4px;
            font-style: italic;
        }

        .message-time {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 4px;
        }

        .details-toggle {
            font-size: 11px;
            margin-top: 6px;
            cursor: pointer;
            opacity: 0.7;
            user-select: none;
            padding: 8px 4px;
            margin: 0 -4px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
        }

        .details-toggle:hover {
            opacity: 1;
        }

        .details-toggle:active {
            opacity: 1;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
        }

        .message-details {
            display: none;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            font-size: 12px;
        }

        .message-details.expanded {
            display: block;
        }

        .detail-item {
            margin-bottom: 4px;
            padding: 4px 0;
        }

        .detail-label {
            font-weight: 600;
            color: var(--text-muted);
        }

        .audio-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            margin-top: 8px;
            padding: 8px 12px;
            margin: 8px -12px 0 -12px;
            border-radius: 6px;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(102, 126, 234, 0.2);
            transition: all 0.2s;
            background: rgba(102, 126, 234, 0.15);
            color: var(--primary);
            animation: subtlePulse 2s ease-in-out infinite;
        }

        .audio-indicator:hover {
            background: rgba(102, 126, 234, 0.25);
        }

        .audio-indicator:active {
            background: rgba(102, 126, 234, 0.35);
            transform: scale(0.98);
        }

        .audio-indicator.playing {
            animation: pulse 1.5s infinite;
            background: rgba(102, 126, 234, 0.3);
        }

        @keyframes subtlePulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 6px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Input Controls */
        .input-controls {
            padding: 15px;
            background: var(--card);
            border-top: 1px solid var(--border);
        }

        .record-btn {
            width: 100%;
            padding: 16px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            background: var(--primary);
            color: white;
        }

        .record-btn:active {
            background: var(--primary-hover);
            transform: scale(0.98);
        }

        .record-btn.recording {
            background: var(--danger);
            animation: pulse 1.5s infinite;
        }

        .recording-timer {
            display: inline-block;
            font-size: 14px;
            font-weight: 700;
            color: white;
            margin-left: 8px;
            font-variant-numeric: tabular-nums;
        }

        .waveform-canvas {
            width: 100%;
            height: 40px;
            margin-bottom: 8px;
            border-radius: 8px;
            background: var(--bg);
            display: none;
        }

        .waveform-canvas.active {
            display: block;
        }

        .hidden {
            display: none !important;
        }

        /* Error Handling */
        .error-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(245, 54, 92, 0.1);
            border: 1px solid var(--danger);
            border-radius: 8px;
            margin: 8px 15px;
            font-size: 12px;
        }

        .error-message {
            flex: 1;
            color: var(--danger);
        }

        .retry-btn {
            padding: 4px 10px;
            font-size: 11px;
            font-weight: 600;
            border: 1px solid var(--danger);
            border-radius: 4px;
            background: white;
            color: var(--danger);
            cursor: pointer;
        }

        .retry-btn:active {
            background: var(--danger);
            color: white;
        }

        /* iPhone notch/safe area support */
        @supports (padding: max(0px)) {
            .container {
                padding-top: max(10px, env(safe-area-inset-top));
                padding-bottom: max(10px, env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üá©üá™ German Tutor</h1>
            <p>Speak naturally, learn through conversation</p>
        </div>

        <div class="content">
            <!-- Session Controls -->
            <div class="session-controls">
                <button id="newSessionBtn">New</button>
                <select id="sessionSelect">
                    <option value="current">Current Session</option>
                </select>
                <button id="deleteSessionBtn">Delete</button>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <span id="status">Connecting...</span>
                <span id="sessionInfo">Level A1</span>
            </div>

            <!-- Chat Container -->
            <div id="chatContainer" class="chat-container">
                <!-- Messages will be rendered here dynamically -->
            </div>

            <!-- Push-to-Talk Button -->
            <div class="input-controls">
                <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
                <button id="recordBtn" class="record-btn">
                    üé§ Tap to Speak
                </button>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // CONFIGURATION
        // ====================================================================

        const API_BASE = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const API_HOST = window.location.host;
        const WS_URL = `${API_BASE}//${API_HOST}/ws/session`;

        // ====================================================================
        // DOM ELEMENTS
        // ====================================================================

        const recordBtn = document.getElementById('recordBtn');
        const statusEl = document.getElementById('status');
        const sessionInfoEl = document.getElementById('sessionInfo');
        const chatContainer = document.getElementById('chatContainer');
        const newSessionBtn = document.getElementById('newSessionBtn');
        const sessionSelect = document.getElementById('sessionSelect');
        const deleteSessionBtn = document.getElementById('deleteSessionBtn');

        // ====================================================================
        // STATE
        // ====================================================================

        let ws = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let mediaStream = null;
        let currentSessionId = null;
        let audioQueue = [];
        let isPlayingAudio = false;
        let lastFailedOperation = null;
        let errorContainer = null;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let audioContext = null;
        let analyser = null;
        let animationFrameId = null;
        let waveformCanvas = null;
        let waveformCtx = null;

        // ====================================================================
        // CHAT UI FUNCTIONS
        // ====================================================================

        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        }

        function setStatusWithSpinner(emoji, text) {
            statusEl.innerHTML = `<span class="spinner"></span>${emoji} ${text}`;
        }

        function setStatus(emoji, text) {
            statusEl.textContent = `${emoji} ${text}`;
        }

        function showError(category, message, retryContext = null) {
            hideError();
            errorContainer = document.createElement('div');
            errorContainer.className = 'error-container';

            let errorIcon = '‚ùå';
            let actionableMessage = message;

            switch(category) {
                case 'connection':
                    errorIcon = 'üì°';
                    actionableMessage = `Connection error: ${message}`;
                    break;
                case 'audio':
                    errorIcon = 'üé§';
                    actionableMessage = `Audio error: ${message}`;
                    break;
                case 'api':
                    errorIcon = '‚ö†Ô∏è';
                    actionableMessage = `Server error: ${message}`;
                    break;
            }

            errorContainer.innerHTML = `
                <span class="error-message">${errorIcon} ${actionableMessage}</span>
                ${retryContext ? '<button class="retry-btn">Retry</button>' : ''}
            `;

            const sessionControls = document.querySelector('.session-controls');
            sessionControls.parentNode.insertBefore(errorContainer, sessionControls.nextSibling);

            if (retryContext) {
                lastFailedOperation = retryContext;
                errorContainer.querySelector('.retry-btn').addEventListener('click', handleRetry);
            }
        }

        function hideError() {
            if (errorContainer) {
                errorContainer.remove();
                errorContainer = null;
            }
        }

        async function handleRetry() {
            if (!lastFailedOperation) return;
            hideError();
            setStatusWithSpinner('‚è≥', 'Retrying...');

            const { type, data } = lastFailedOperation;
            if (type === 'audio') await sendAudioToBackend(data);
            if (type === 'websocket') connectWebSocket();
        }

        function formatRecordingTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startRecordingTimer() {
            recordingStartTime = Date.now();
            recordingTimerInterval = setInterval(() => {
                const elapsed = Date.now() - recordingStartTime;
                const timer = document.querySelector('.recording-timer');
                if (timer) timer.textContent = formatRecordingTime(elapsed);
            }, 100);
        }

        function stopRecordingTimer() {
            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }
        }

        function initWaveform() {
            waveformCanvas = document.getElementById('waveformCanvas');
            waveformCtx = waveformCanvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = waveformCanvas.getBoundingClientRect();
            waveformCanvas.width = rect.width * dpr;
            waveformCanvas.height = rect.height * dpr;
            waveformCtx.scale(dpr, dpr);
        }

        function startWaveform(stream) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 64;
            analyser.smoothingTimeConstant = 0.8;

            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);

            waveformCanvas.classList.add('active');
            drawWaveform();
        }

        function drawWaveform() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const draw = () => {
                animationFrameId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                const rect = waveformCanvas.getBoundingClientRect();
                waveformCtx.clearRect(0, 0, rect.width, rect.height);

                const barWidth = (rect.width / bufferLength) * 0.8;
                const barGap = (rect.width / bufferLength) * 0.2;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * rect.height * 0.8;
                    const x = i * (barWidth + barGap);
                    const y = rect.height - barHeight;

                    const gradient = waveformCtx.createLinearGradient(0, y, 0, rect.height);
                    gradient.addColorStop(0, '#f5365c');
                    gradient.addColorStop(1, '#667eea');

                    waveformCtx.fillStyle = gradient;
                    waveformCtx.fillRect(x, y, barWidth, barHeight);
                }
            };
            draw();
        }

        function stopWaveform() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (waveformCanvas) {
                waveformCanvas.classList.remove('active');
                const rect = waveformCanvas.getBoundingClientRect();
                waveformCtx.clearRect(0, 0, rect.width, rect.height);
            }
            if (analyser) {
                analyser.disconnect();
                analyser = null;
            }
        }

        function renderUserMessage(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';

            const timestamp = data.timestamp || new Date().toISOString();
            const original = data.original_german || '';
            const corrected = data.corrected_german || original;
            const translation = data.english_translation || '';
            const corrections = data.corrections || [];

            // Build message text with inline corrections
            let messageText = corrected;
            if (corrections.length > 0 && original !== corrected) {
                // Show both original (strikethrough) and corrected
                messageText = `<span class="correction">${original}</span> ‚Üí <span class="corrected">${corrected}</span>`;
            }

            let html = `
                <div class="message-bubble">
                    <div class="message-text">${messageText}</div>
                    ${translation ? `<div class="message-translation">${translation}</div>` : ''}
                    <div class="message-time">${formatTime(timestamp)}</div>
                    ${corrections.length > 0 ? '<div class="details-toggle">Show details ‚ñº</div>' : ''}
                </div>
            `;

            // Add details section if there are corrections
            if (corrections.length > 0) {
                let detailsHtml = '<div class="message-details">';
                corrections.forEach(corr => {
                    detailsHtml += `
                        <div class="detail-item">
                            <span class="detail-label">${corr.type}:</span>
                            "${corr.original}" ‚Üí "${corr.corrected}"
                            ${corr.reason ? `<br><small>${corr.reason}</small>` : ''}
                        </div>
                    `;
                });

                // Add pronunciation feedback if available
                if (data.pronunciation && data.pronunciation.issue) {
                    detailsHtml += `
                        <div class="detail-item">
                            <span class="detail-label">Pronunciation:</span>
                            ${data.pronunciation.issue}
                        </div>
                    `;
                }

                detailsHtml += '</div>';
                html += detailsHtml;
            }

            messageDiv.innerHTML = html;

            // Add click and touch handler for details toggle
            const toggle = messageDiv.querySelector('.details-toggle');
            const details = messageDiv.querySelector('.message-details');
            if (toggle && details) {
                const toggleDetails = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    details.classList.toggle('expanded');
                    toggle.textContent = details.classList.contains('expanded')
                        ? 'Hide details ‚ñ≤'
                        : 'Show details ‚ñº';
                };

                toggle.addEventListener('click', toggleDetails);
                toggle.addEventListener('touchend', toggleDetails);
            }

            chatContainer.appendChild(messageDiv);
            scrollToBottom();
        }

        function renderAgentMessage(data) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent';

            const timestamp = data.timestamp || new Date().toISOString();
            const germanText = data.german_text || '';
            const translation = data.english_translation || '';
            const hasTTS = data.tts_audio ? true : false;
            const explanations = data.assistant_explanations || [];

            let html = `
                <div class="message-bubble">
                    <div class="message-text">${germanText}</div>
                    ${translation ? `<div class="message-translation">${translation}</div>` : ''}
                    <div class="message-time">${formatTime(timestamp)}</div>
                    ${hasTTS ? '<div class="audio-indicator" data-audio-ready="true">üîä H√∂r zu! (Tap to listen)</div>' : ''}
                    ${explanations.length > 0 ? '<div class="details-toggle">Show details ‚ñº</div>' : ''}
                </div>
            `;

            // Add details section if there are explanations
            if (explanations.length > 0) {
                let detailsHtml = '<div class="message-details">';
                explanations.forEach(exp => {
                    detailsHtml += `
                        <div class="detail-item">
                            <span class="detail-label">${exp.word}:</span>
                            ${exp.meaning}
                            ${exp.usage ? `<br><small>${exp.usage}</small>` : ''}
                        </div>
                    `;
                });
                detailsHtml += '</div>';
                html += detailsHtml;
            }

            messageDiv.innerHTML = html;

            // Add click and touch handler for details toggle
            const toggle = messageDiv.querySelector('.details-toggle');
            const details = messageDiv.querySelector('.message-details');
            if (toggle && details) {
                const toggleDetails = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    details.classList.toggle('expanded');
                    toggle.textContent = details.classList.contains('expanded')
                        ? 'Hide details ‚ñ≤'
                        : 'Show details ‚ñº';
                };

                toggle.addEventListener('click', toggleDetails);
                toggle.addEventListener('touchend', toggleDetails);
            }

            chatContainer.appendChild(messageDiv);
            scrollToBottom();

            // Pre-create audio for Safari iOS compatibility
            if (hasTTS && data.tts_audio) {
                const indicator = messageDiv.querySelector('.audio-indicator');

                // Convert base64 to blob URL IMMEDIATELY (before user interaction)
                const audioBlob = base64ToBlob(data.tts_audio, 'audio/mpeg');
                const audioUrl = URL.createObjectURL(audioBlob);
                const audioElement = new Audio();
                audioElement.src = audioUrl;
                audioElement.preload = 'auto';
                audioElement.load(); // Force load for Safari

                let isPlaying = false;

                // Setup event listeners
                audioElement.addEventListener('ended', () => {
                    indicator.classList.remove('playing');
                    indicator.textContent = '‚úì Played';
                    isPlaying = false;
                });

                audioElement.addEventListener('error', (e) => {
                    console.error('Audio error:', e, audioElement.error);
                    indicator.textContent = '‚ùå Tap to retry';
                    indicator.classList.remove('playing');
                    isPlaying = false;
                });

                // Safari-compatible play - MUST be synchronous in user gesture
                const playAudio = (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    if (isPlaying) return;
                    isPlaying = true;

                    indicator.textContent = 'üîä Playing...';
                    indicator.classList.add('playing');

                    // Play MUST happen synchronously for Safari iOS
                    const playPromise = audioElement.play();

                    if (playPromise !== undefined) {
                        playPromise.catch((error) => {
                            console.error('Play failed:', error);
                            indicator.textContent = '‚ùå Tap to retry';
                            indicator.classList.remove('playing');
                            isPlaying = false;
                        });
                    }
                };

                // Use touchstart for immediate response on iOS
                indicator.addEventListener('touchstart', playAudio, { passive: false });
                indicator.addEventListener('click', playAudio);
            }
        }

        // ====================================================================
        // TTS AUDIO PLAYBACK
        // ====================================================================

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }

        async function processAudioQueue() {
            if (isPlayingAudio || audioQueue.length === 0) {
                return;
            }

            isPlayingAudio = true;
            const { audio, indicator } = audioQueue.shift();

            try {
                const audioBlob = base64ToBlob(audio, 'audio/mpeg');
                const audioUrl = URL.createObjectURL(audioBlob);
                const audioElement = new Audio(audioUrl);

                indicator.classList.add('playing');
                indicator.textContent = 'üîä Playing...';

                audioElement.addEventListener('ended', () => {
                    indicator.classList.remove('playing');
                    indicator.textContent = '‚úì Played';
                    URL.revokeObjectURL(audioUrl);
                    isPlayingAudio = false;
                    // Process next in queue
                    processAudioQueue();
                });

                audioElement.addEventListener('error', () => {
                    indicator.textContent = '‚ùå Playback error';
                    URL.revokeObjectURL(audioUrl);
                    isPlayingAudio = false;
                    processAudioQueue();
                });

                await audioElement.play();
            } catch (error) {
                console.error('Audio playback error:', error);
                indicator.textContent = '‚ùå Playback failed';
                isPlayingAudio = false;
                processAudioQueue();
            }
        }

        // ====================================================================
        // WEBSOCKET CONNECTION
        // ====================================================================

        function connectWebSocket() {
            ws = new WebSocket(WS_URL);

            ws.addEventListener('open', () => {
                statusEl.textContent = '‚úÖ Connected';
            });

            ws.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'status') {
                        // Keep spinner for processing messages
                        if (data.message.includes('Processing') || data.message.includes('üîÑ') || data.message.includes('üìù')) {
                            statusEl.innerHTML = `<span class="spinner"></span>${data.message}`;
                        } else {
                            statusEl.textContent = data.message;
                        }
                    }
                    else if (data.type === 'conversation') {
                        // New format: render chat bubbles
                        if (data.user_message) {
                            renderUserMessage({
                                timestamp: data.timestamp,
                                original_german: data.user_message.original_german,
                                corrected_german: data.user_message.corrected_german,
                                english_translation: data.user_message.english_translation,
                                corrections: data.user_message.corrections,
                                pronunciation: data.user_message.pronunciation
                            });
                        }

                        if (data.agent_message) {
                            renderAgentMessage({
                                timestamp: data.timestamp,
                                german_text: data.agent_message.german_text,
                                english_translation: data.agent_message.english_translation,
                                tts_audio: data.agent_message.tts_audio
                            });
                        }

                        hideError();
                        statusEl.textContent = '‚úÖ Ready';
                    }
                    else if (data.type === 'correction') {
                        // Legacy format support (backwards compatibility)
                        renderUserMessage({
                            original_german: data.original_german || '',
                            corrected_german: data.corrected_german || '',
                            english_translation: data.english_translation || '',
                            corrections: data.corrections || [],
                            pronunciation: data.pronunciation
                        });

                        if (data.agent_response) {
                            renderAgentMessage({
                                german_text: data.agent_response,
                                english_translation: '',
                                tts_audio: null
                            });
                        }

                        hideError();
                        statusEl.textContent = '‚úÖ Ready';
                    }
                    else if (data.type === 'error') {
                        // Check for specific error categories
                        if (data.error_category === 'audio_quality') {
                            showError('audio', data.message);
                        } else {
                            showError('api', data.message);
                        }
                    }
                } catch (e) {
                    console.error('WebSocket message error:', e);
                }
            });

            ws.addEventListener('error', (error) => {
                showError('connection', 'Lost connection', {type: 'websocket'});
                console.error('WebSocket error:', error);
            });

            ws.addEventListener('close', () => {
                statusEl.textContent = '‚ö†Ô∏è Reconnecting...';
                // Attempt reconnect after 3 seconds
                setTimeout(connectWebSocket, 3000);
            });
        }

        // ====================================================================
        // SESSION MANAGEMENT
        // ====================================================================

        async function loadSessionList() {
            try {
                const response = await fetch('/api/sessions');
                const data = await response.json();

                sessionSelect.innerHTML = '<option value="current">Current Session</option>';

                if (data.sessions && data.sessions.length > 0) {
                    data.sessions.forEach(session => {
                        const option = document.createElement('option');
                        option.value = session.session_id;
                        option.textContent = `${new Date(session.start_time).toLocaleString()} (${session.exchanges} exchanges)`;
                        sessionSelect.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading sessions:', error);
            }
        }

        async function loadSessionMessages(sessionId) {
            try {
                const response = await fetch(`/api/sessions/${sessionId}`);
                const data = await response.json();

                // Clear chat
                chatContainer.innerHTML = '';

                // Render all exchanges
                if (data.conversation_log) {
                    data.conversation_log.forEach(exchange => {
                        renderUserMessage({
                            timestamp: exchange.timestamp,
                            original_german: exchange.user_input,
                            corrected_german: exchange.user_corrected,
                            english_translation: exchange.user_translation,
                            corrections: exchange.corrections || [],
                            pronunciation: exchange.pronunciation
                        });

                        if (exchange.agent_response) {
                            renderAgentMessage({
                                timestamp: exchange.timestamp,
                                german_text: exchange.agent_response,
                                english_translation: '',
                                tts_audio: null  // Historical messages don't have audio
                            });
                        }
                    });
                }
            } catch (error) {
                console.error('Error loading session:', error);
                statusEl.textContent = '‚ùå Failed to load session';
            }
        }

        newSessionBtn.addEventListener('click', async () => {
            if (confirm('Start a new session? Current conversation will be saved.')) {
                chatContainer.innerHTML = '';
                currentSessionId = null;
                statusEl.textContent = '‚úÖ New session started';

                try {
                    const response = await fetch('/api/sessions/new', { method: 'POST' });
                    const data = await response.json();
                    currentSessionId = data.session_id;
                    sessionInfoEl.textContent = `Session ${data.session_number} | Level ${data.learner_level}`;
                } catch (error) {
                    console.error('Error creating session:', error);
                }

                loadSessionList();
            }
        });

        sessionSelect.addEventListener('change', (e) => {
            const sessionId = e.target.value;
            if (sessionId === 'current') {
                // Stay on current session
                return;
            }
            loadSessionMessages(sessionId);
        });

        deleteSessionBtn.addEventListener('click', async () => {
            const selectedSession = sessionSelect.value;
            if (selectedSession === 'current') {
                alert('Cannot delete current session');
                return;
            }

            // Find the filename from the selected session
            const selectedOption = sessionSelect.options[sessionSelect.selectedIndex];
            if (!selectedOption) return;

            if (confirm('Delete this session permanently?')) {
                try {
                    // Extract filename from session list
                    const response = await fetch('/api/sessions');
                    const data = await response.json();
                    const session = data.sessions.find(s => s.session_id === selectedSession);

                    if (session) {
                        await fetch(`/api/sessions/${session.filename}`, { method: 'DELETE' });
                        statusEl.textContent = '‚úÖ Session deleted';
                        loadSessionList();
                        sessionSelect.value = 'current';
                    }
                } catch (error) {
                    console.error('Error deleting session:', error);
                    statusEl.textContent = '‚ùå Failed to delete session';
                }
            }
        });

        // ====================================================================
        // AUDIO RECORDING (Tap to Start/Stop)
        // ====================================================================

        let recordingTimeout = null;
        const MAX_RECORDING_TIME = 60000; // 60 seconds safety limit

        async function startRecording() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 24000
                    }
                });

                // Try to use audio formats that Whisper API handles better
                // Prefer MP4/M4A which is more compatible than WebM/Opus
                let mimeType = 'audio/webm';
                const preferredTypes = ['audio/mp4', 'audio/mpeg', 'audio/webm;codecs=opus'];

                for (const type of preferredTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        mimeType = type;
                        console.log(`Using audio format: ${mimeType}`);
                        break;
                    }
                }

                mediaRecorder = new MediaRecorder(mediaStream, { mimeType });
                audioChunks = [];

                mediaRecorder.addEventListener('dataavailable', (event) => {
                    audioChunks.push(event.data);
                });

                mediaRecorder.addEventListener('stop', async () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    await sendAudioToBackend(audioBlob);
                });

                mediaRecorder.start();
                isRecording = true;

                recordBtn.classList.add('recording');
                recordBtn.innerHTML = '‚èπÔ∏è Tap to Stop <span class="recording-timer">0:00</span>';
                statusEl.textContent = 'üé§ Listening...';
                startRecordingTimer();
                startWaveform(mediaStream);

                // Safety timeout: auto-stop after 60 seconds
                recordingTimeout = setTimeout(() => {
                    statusEl.textContent = '‚ö†Ô∏è Max recording time reached';
                    stopRecording();
                }, MAX_RECORDING_TIME);

            } catch (error) {
                showError('audio', 'Microphone access denied');
                console.error('Microphone error:', error);
            }
        }

        function stopRecording() {
            if (!isRecording) return; // Not recording

            // Clear safety timeout
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }

            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();

                // Stop all media tracks
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
            }

            stopRecordingTimer();
            stopWaveform();
            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'üé§ Tap to Speak';
            setStatusWithSpinner('‚è≥', 'Processing...');
            isRecording = false;
        }

        // Toggle recording on click/tap
        function toggleRecording(e) {
            e.preventDefault();

            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        // Single event listener for both desktop and mobile
        recordBtn.addEventListener('click', toggleRecording);

        recordBtn.addEventListener('touchcancel', (e) => {
            if (isRecording) {
                stopRecording(e);
            }
        });

        // ====================================================================
        // SEND AUDIO TO BACKEND
        // ====================================================================

        async function sendAudioToBackend(audioBlob) {
            try {
                // Convert blob to base64
                const reader = new FileReader();

                reader.onload = () => {
                    const base64Audio = reader.result.split(',')[1];

                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: "audio",
                            audio: base64Audio
                        }));
                        hideError();
                    } else {
                        showError('connection', 'WebSocket not connected', {type: 'websocket'});
                    }
                };

                reader.onerror = () => {
                    showError('audio', 'Error reading audio file', {type: 'audio', data: audioBlob});
                };

                reader.readAsDataURL(audioBlob);

            } catch (error) {
                showError('api', error.message, {type: 'audio', data: audioBlob});
                console.error('Audio send error:', error);
            }
        }

        // ====================================================================
        // INITIALIZATION
        // ====================================================================

        window.addEventListener('load', async () => {
            connectWebSocket();
            loadSessionList();
            initWaveform();

            // Load learner profile info
            try {
                const response = await fetch('/api/profile');
                const profile = await response.json();
                sessionInfoEl.textContent = `Level ${profile.current_level}`;
            } catch (error) {
                console.error('Error loading profile:', error);
            }

            // Request notification permission for future features
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        });

        // ====================================================================
        // PAGE UNLOAD
        // ====================================================================

        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.send(JSON.stringify({ type: "end_session" }));
                ws.close();
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
